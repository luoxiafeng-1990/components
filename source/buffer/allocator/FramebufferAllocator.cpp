#include "../../../include/buffer/allocator/FramebufferAllocator.hpp"
#include "../../../include/display/LinuxFramebufferDevice.hpp"
#include <stdio.h>

// ============================================================
// æ„é€ /ææ„å‡½æ•°
// ============================================================

FramebufferAllocator::FramebufferAllocator(const std::vector<BufferInfo>& external_buffers)
    : external_buffers_(external_buffers)
    , next_buffer_index_(0)
{
    printf("ğŸ”§ FramebufferAllocator created with %zu external buffers\n", 
           external_buffers_.size());
}

FramebufferAllocator::FramebufferAllocator(LinuxFramebufferDevice* device)
    : next_buffer_index_(0)
{
    if (!device) {
        printf("âŒ ERROR: Device pointer is null\n");
        return;
    }
    
    // è°ƒç”¨ç§æœ‰æ–¹æ³•æ„å»º BufferInfo åˆ—è¡¨
    external_buffers_ = buildBufferInfosFromDevice(device);
    
    printf("ğŸ”§ FramebufferAllocator created from device with %zu buffers\n", 
           external_buffers_.size());
}

FramebufferAllocator::~FramebufferAllocator() {
    printf("ğŸ§¹ FramebufferAllocator destroyed (external memory not freed)\n");
}

// ============================================================
// é‡å†™æ‰¹é‡åˆ†é…ï¼ˆæ‰¹é‡åŒ…è£…ï¼‰
// ============================================================

std::unique_ptr<BufferPool> FramebufferAllocator::allocatePoolWithBuffers(
    int count,
    size_t size,
    const std::string& name,
    const std::string& category)
{
    // å¿½ç•¥ count å’Œ sizeï¼Œä½¿ç”¨ external_buffers_ çš„å®é™…æ•°é‡
    int actual_count = static_cast<int>(external_buffers_.size());
    
    printf("\nğŸ­ FramebufferAllocator: Wrapping %d external buffers to pool '%s'...\n",
           actual_count, name.c_str());
    
    // 1. åˆ›å»ºç©ºæ± 
    auto pool = BufferPool::CreateEmpty(name, category);
    if (!pool) {
        printf("âŒ Failed to create empty pool\n");
        return nullptr;
    }
    
    // 2. æ‰¹é‡åŒ…è£…å¤–éƒ¨ Buffer
    for (int i = 0; i < actual_count; i++) {
        Buffer* buffer = createBuffer(i, 0);  // size å‚æ•°è¢«å¿½ç•¥
        if (!buffer) {
            printf("âŒ Failed to wrap external buffer #%d\n", i);
            // å¤±è´¥ï¼šæ¸…ç†å·²åˆ›å»ºçš„ buffer å¯¹è±¡
            cleanupPool(pool.get());
            return nullptr;
        }
        
        // 3. é€šè¿‡åŸºç±»è¾…åŠ©æ–¹æ³•æ·»åŠ åˆ° pool çš„ free é˜Ÿåˆ—
        if (!addBufferToPoolQueue(pool.get(), buffer, QueueType::FREE)) {
            printf("âŒ Failed to add buffer #%d to pool\n", i);
            deallocateBuffer(buffer);
            cleanupPool(pool.get());
            return nullptr;
        }
        
        // 4. è®°å½•æ‰€æœ‰æƒ
        registerBufferOwnership(buffer, this);
        
        printf("   âœ… Buffer #%d wrapped: virt=%p, phys=0x%lx, size=%zu (EXTERNAL)\n",
               i, buffer->getVirtualAddress(), buffer->getPhysicalAddress(), buffer->size());
    }
    
    printf("âœ… BufferPool '%s' created with %d external buffers by FramebufferAllocator\n", 
           name.c_str(), actual_count);
    
    return pool;
}

// ============================================================
// æ ¸å¿ƒå®ç°
// ============================================================

Buffer* FramebufferAllocator::createBuffer(uint32_t id, size_t size) {
    // æ£€æŸ¥ id æ˜¯å¦è¶Šç•Œ
    if (id >= external_buffers_.size()) {
        printf("âŒ Buffer ID %u out of range (max: %zu)\n", 
               id, external_buffers_.size());
        return nullptr;
    }
    
    // è·å–å¤–éƒ¨ buffer ä¿¡æ¯
    const BufferInfo& info = external_buffers_[id];
    
    // åˆ›å»º Buffer å¯¹è±¡ï¼ˆOwnership::EXTERNALï¼‰
    Buffer* buffer = new Buffer(
        id,
        info.virt_addr,
        info.phys_addr,
        info.size,
        Buffer::Ownership::EXTERNAL
    );
    
    if (!buffer) {
        printf("âŒ Failed to create Buffer object #%u\n", id);
        return nullptr;
    }
    
    return buffer;
}

void FramebufferAllocator::deallocateBuffer(Buffer* buffer) {
    if (!buffer) {
        return;
    }
    
    // 1. ä¸é‡Šæ”¾å†…å­˜ï¼ˆå¤–éƒ¨ç®¡ç†ï¼‰
    printf("   ğŸ—‘ï¸ Deleting Buffer #%u (external memory retained)\n", buffer->id());
    
    // 2. ä»…åˆ é™¤ Buffer å¯¹è±¡
    delete buffer;
}

// ============================================================
// ç§æœ‰è¾…åŠ©æ–¹æ³•ï¼šä»è®¾å¤‡æ„å»º BufferInfo åˆ—è¡¨
// ============================================================

std::vector<FramebufferAllocator::BufferInfo> 
FramebufferAllocator::buildBufferInfosFromDevice(LinuxFramebufferDevice* device)
{
    std::vector<BufferInfo> infos;
    
    if (!device) {
        printf("âŒ ERROR: Device pointer is null in buildBufferInfosFromDevice\n");
        return infos;
    }
    
    // 1. ä»è®¾å¤‡è·å– mmap ä¿¡æ¯
    auto mapped_info = device->getMappedInfo();
    
    printf("ğŸ“‹ Building BufferInfo list from device:\n");
    printf("   base_addr=%p, buffer_size=%zu, buffer_count=%d\n",
           mapped_info.base_addr, mapped_info.buffer_size, mapped_info.buffer_count);
    
    // 2. è®¡ç®—æ¯ä¸ª buffer çš„åœ°å€å¹¶æ„å»º BufferInfo
    unsigned char* base = (unsigned char*)mapped_info.base_addr;
    infos.reserve(mapped_info.buffer_count);
    
    for (int i = 0; i < mapped_info.buffer_count; i++) {
        infos.push_back({
            .virt_addr = (void*)(base + i * mapped_info.buffer_size),
            .phys_addr = 0,  // ç‰©ç†åœ°å€ç”±ç³»ç»Ÿè‡ªåŠ¨è·å–
            .size = mapped_info.buffer_size
        });
        
        printf("   Buffer[%d]: virt=%p, size=%zu\n", 
               i, infos.back().virt_addr, infos.back().size);
    }
    
    return infos;
}

